apply plugin: 'war'

version = new ProjectVersion(0, 1)

ext.versionFile = file('version.properties')

task loadVersion() {
	project.version = readVersion()
}

ProjectVersion readVersion() {
	logger.quiet 'Reading the version file.'
	
	if(!versionFile.exists()) {
		throw new GradleException("Required version file does note exist: $versionFile.canonicalPath")
	}
	
	Properties versionProps = new Properties()
	
	versionFile.withInputStream { stream ->
		versionProps.load(stream)
	}
	
	new ProjectVersion(
		versionProps.major.toInteger(),
		versionProps.minor.toInteger(),
		versionProps.release.toBoolean())
}

task first {
	println "first"
}

task second {
	println "second"
}

task third {
	println "third"
}

third.dependsOn('printVersion')

task printVersion (dependsOn: ['second', 'first']) {
	logger.quiet "Version: ${version}"
}

class ProjectVersion {
	Integer major
	Integer minor
	Boolean release
	
	ProjectVersion(Integer major, Integer minor) {
		this(major, minor, Boolean.FALSE)
	}
	
	ProjectVersion(Integer major, Integer minor, Boolean release) {
		this.major = major
		this.minor = minor
		this.release = release
	}
	
	@Override
	String toString() {
		return "${major}.${minor}-${release ? 'RELEASE' : 'SNAPSHOT'}"
	}
	
}

class ReleaseVersionTask extends DefaultTask {
	@Input Boolean release
	@OutputFile File destFile
	
	ReleaseVersionTask() {
		group = 'Version'
		description = 'Change project type to release'
	}
	
	@TaskAction
	void start() {
		project.version.release = true
		ant.propertyfile(file: project.versionFile) {
			entry(
				key: 'release', 
				type: 'string', 
				operation: '=', 
				value: 'true')
		}
	}
}

task makeReleaseVersion(type: ReleaseVersionTask) {
	release = project.version.release
	destFile = project.versionFile
}
/*
task makeReleaseVersion(group: 'Version', description: 'Makes project a release version') {
	version.release = true
	
	inputs.property('release', version.release)
	outputs.file versionFile
	
	ant.propertyfile(file: versionFile) {
		entry(
			key: 'release', 
			type: 'string', 
			operation: '=', 
			value: 'true')
	}
}
*/
task makeSnapshotVersion(group: 'Version', description: 'Makes project a snapshot version') {
	version.release = false
	
	inputs.property('release', version.release)
	outputs.file versionFile
	
	ant.propertyfile(file: versionFile) {
		entry(key: 'release', type: 'string', operation: '=', value: 'false')
	}
}

task createDistribution(type: Zip, dependsOn: makeReleaseVersion){
	from war.outputs.files
	
	from (sourceSets*.allSource){
		into 'src'
	}
	
	from (rootDir){
		include versionFile.name
	}
}

task backupDistribution(type: Copy){
	from createDistribution.outputs.files
	into "$buildDir/backup"
}

tasks.addRule("Pattern: (in|de)crement<Classifier>Version - increments the project version classifier"){
	String taskname ->

	String operacion

		if(taskname.startsWith("increment") && taskname.endsWith("Version")){
			operacion="+"
		}
		else if(taskname.startsWith("decrement") && taskname.endsWith("Version")){
			operacion="-"
		}

		if(operacion != null){
			task(taskname)<<{
				String classifier=(taskname - 'increment' - 'Version')
				String currentVersion = version.toString()

				switch(classifier){
					case 'Major': operacion=="+" ? ++version.major : --version.major; break;
					case 'Minor': operacion=="+" ? ++version.minor : --version.minor; break;
					default: throw new GradleException("Classifier must be 'Major' or 'Minor'.");
				}

				String newVersion = version.toString()

				println "Incremented version from ${currentVersion} to ${newVersion}"

				ant.propertyfile(file: project.versionFile) {
					entry(
						key: classifier.toLowerCase(), 
						type: 'int', 
						operation: operacion, 
						value: 1)
				}

			}

		}
}





